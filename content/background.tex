\subsection{Bakgrunn}
I dette prosjektet, verktøyene som er brukt for å utføre eksperimenter på emnet er Scheduler som er endel av IBM sitt ILOG CP produkt\nomenclature{CP}{Begrensningsprogrammering (engelsk: Constraint programming)}. Scheduler er et C++ bibliotek som gjør det mulig å definere planleggingsbegrensninger i form av ressurser og aktiviteter. Planlegging er en prosess hvor det tildeles ressurser til aktiviteter og tid til de forskjellige aktiviteter slik at det ikke oppstår noen konflikt med begrensningene \cite{Pape94implementationof}. Automatisk planlegging er endel av det som kalles kunstig intelligens (AI) \nomenclature{AI}{Kunstig intelligens (engelsk: artificial inteligence)}. \colorbox{red}{Skriv litt mer om sammenheng AI og prosjektet}

I kompleksitetsteori \cite{compcomplextheory} kaller man problemer som er minst like vanskelige å løse som de vanskeligste problemene i kategorien \textit{NP} som \textit{NP-hard}. NP er kategorien av problemer som kan løses i polynomisk tid på en ikke-detministisk Turing  maskin. Det er forskjellige kategorier av NP-harde problemer, avgjøreksesproblemer, søkeproblemer og optimaliseringsproblemer \cite{nphardwikipedia}. Problemet i dette prosjektet er i kategorien optimaliseringsproblem. Fra wikipedia \cite{optimizationproblemwiki} er et optimaliseringsproblem: ''Et problem med å finne den beste løsningen ut ifra alle gyldige løsninger".

Taillard \cite{Taillard1993278} har sett på benchmarking i enkle planleggingsproblemer og sett på hvordan best mulig benchmarke vanskelige problemer. De har definert vanskelige problemer med å se på makespan og hvor langt unna den er den nedre grensen. De har tatt utgangspunkt i tre kjente begrensningsproblemer og laget benchmarksett til disse. Taillard har definert nedregrensen ($ C^{*}_{max} $) i JSSP som større enn eller lik maksimale mellom den minste tiden krevd av maskinene og den minste tiden krevd av hver enkel jobb. Wallace \cite{Wallace:2004:BCL:956860.956861} har også sett på benchmarking og tatt for seg porsitive og negative sider ved benchmarking. Benchmarking har to hovedoppgaver, hvor det første er å dekke et representativt problem og bredt programmerings begrep. Den andre oppgaven er benchmarking av applikasjoner med ''unit tester". Utfordringen med begge er å opprette en klar målsetting for ytelsen. Teoretisk sett er den mest ideele måten å benchmarke en applikasjon å implementere en løsning for hvert system og velge den beste, men dette er ikke alltid mulig i praksis. Måten da å gjøre det på i praksis er å benchmarke systemer med forhåndsdefinerte problemer og håpe resultatet kan bli overført til applikasjonen som krever det. Wallace tar også opp vanskeligheten med tidsmekanismer i høynivåspråk, da dette ofte er basert på CPU tid.