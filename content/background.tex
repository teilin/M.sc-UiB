\subsection{Bakgrunn}
I denne prosjektoppgaven er verktøyet som er brukt for å utføre eksperimenter på emnet, Scheduler. Dette er en del av IBM sitt ILOG CP produkt\nomenclature{CP}{Begrensningsprogrammering (engelsk: Constraint programming)}. Scheduler er et C++ bibliotek som gjør det mulig å definere planleggingsbegrensninger i form av ressurser og aktiviteter. Planlegging er her en prosess hvor det tildeles ressurser til aktiviteter og tid til de forskjellige aktivitetene slik at det ikke oppstår noen konflikt med begrensningene \cite{Pape94implementationof}. Automatisk planlegging er en del av det som kalles kunstig intelligens (AI)\nomenclature{AI}{Kunstig intelligens (engelsk: artificial inteligence)}.

I kompleksitetsteori \cite{compcomplextheory} kaller man problemer som er minst like vanskelige å løse som de vanskeligste problemene i kategorien \textit{NP}, som \textit{NP-hard}. NP er kategorien av problemer som kan løses i polynomisk tid på en ikke-deterministisk Turing maskin. Det er forskjellige kategorier av NP-hard problemer. Dette er avgjørelsesproblemer, søkeproblemer og optimaliseringsproblemer \cite{nphardwikipedia}. Problemet i prosjektoppgaven er i kategorien optimaliseringsproblem. Fra wikipedia \cite{optimizationproblemwiki} er et optimaliseringsproblem: ''Et problem med å finne den beste løsningen ut ifra alle gyldige løsninger".

Taillard \cite{Taillard1993278} har sett på benchmarking i enkle planleggingsproblemer som grunnlag for hvordan man best mulig benchmarker vanskelige problemer. Han har definert vanskelige problemer ved å se på makespan og hvor langt unna makespan er teoretisk nedre grensen. Han har tatt utgangspunkt i tre kjente begrensningsproblemer og laget benchmarksett til disse.

Wallace \cite{Wallace:2004:BCL:956860.956861} har også sett på benchmarking og tatt for seg positive og negative sider ved dette. Benchmarking har to hovedfunksjoner. Den første er å dekke et representativt problem og bredt programmeringsbegrep. Den andre er benchmarking av applikasjoner med ''enhetstester". Utfordringen med begge er å opprette en klar målsetting for ytelsen. Teoretisk sett er den mest idele måten å benchmarke en applikasjon på å implementere en løsning for hvert system for så å velge den beste. Men dette er ikke alltid mulig i praksis. Måten å gjøre dette på i praksis, er å benchmarke systemer med forhåndsdefinerte problemer og håpe at resultatet kan bli overført til applikasjonen som skal bruke det. Wallace tar også opp vanskeligheten med tidsmekanismer i høynivåspråk. Tidsmekanismer er vanligvis basert på CPU tid som kan variere fra maskinoppsett til maskinoppsett og defor kan gi unøyaktigheter i banchmarkingen.